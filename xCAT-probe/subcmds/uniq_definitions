#! /usr/bin/perl
# IBM(c) 2016 EPL license http://www.eclipse.org/legal/epl-v10.html

BEGIN { $::XCATROOT = $ENV{'XCATROOT'} ? $ENV{'XCATROOT'} : -d '/opt/xcat' ? '/opt/xcat' : '/usr'; }

use lib "$::XCATROOT/probe/lib/perl";
use probe_utils;
use File::Basename;
use Net::Ping;
use Getopt::Long qw(:config no_ignore_case);

use Data::Dumper;
use warnings;

my $program_name = basename("$0");
my $help;
my $noderange = "";
my $test;
my $output  = "stdout";
my $verbose = 0;
my $rst     = 0;
# Match pattern for discovered nodes: node-1234-ABCDE-123456
#                                     node- d+ -[a-z]- d+
my $discovered_node_pattern = '^node-\d+-[a-zA-Z]+-\d+';

$::USAGE = "Usage:
    $program_name -h
    $program_name [-d] [-n noderange] [-V]

Description:
    Use this command to check if any node defintions in xCAT DB have duplicate model type and serial numbers. 

Options:
    -h : Get usage information of $program_name
    -n : Range of nodes to check
    -d : Remode duplicate model type and serial number node definition from xCAT DB
    -V : To print additional debug information.
";

#-------------------------------------
# main process
#-------------------------------------
if (
    !GetOptions("--help|h" => \$help,
        "T"   => \$test,
        "V"   => \$VERBOSE,
        "n=s" => \$noderange,
        "d"   => \$DELETE_DUPLICATE))
{
    probe_utils->send_msg("$output", "f", "Invalid parameter for $program_name");
    probe_utils->send_msg("$output", "d", "$::USAGE");
    exit 1;
}

if ($help) {
    if ($output ne "stdout") {
        probe_utils->send_msg("$output", "d", "$::USAGE");
    } else {
        print "$::USAGE";
    }
    exit 0;
}

if ($test) {
    probe_utils->send_msg("$output", "o", "Use this command to check if any node defintions in xCAT DB have duplicate model type and serial numbers.");
    exit 0;
}

if (scalar(@ARGV) >= 1) {

    # After processing all the expected flags and arguments,
    # there is still left over stuff on the command line
    probe_utils->send_msg("$output", "f", "Invalid flag or parameter: @ARGV");
    probe_utils->send_msg("$output", "d", "$::USAGE");
    exit 1;
}

my $na = "N/A";

my %node_mtm_serial_hash;
my %mtm_serial_node_hash;
my %waiting_to_be_discovered;

my $all_nodes_mtm_serial   = `lsdef -i mtm,serial -c $noderange`;
chomp($all_nodes_mtm_serial);
my @all_nodes_mtm_serial_lines   = split("[\n\r]", $all_nodes_mtm_serial);

if ($all_nodes_mtm_serial =~ /Usage:/) {

    # lsdef command displayed a Usage message. Must be some noderange formatting problem.
    # Issue a warning and exit.
    probe_utils->send_msg("$output", "w", "Can not get a list of nodes from specified noderange.");
    exit 1;
}

if (scalar(@all_nodes_mtm_serial_lines) <= 0) {

    # There were no nodes matching the noderange. Issue a warning and exit.
    probe_utils->send_msg("$output", "w", "No nodes matching the noderange were found.");
    exit 1;
}

# Build a hash of key="nodename" value="mtm+serial"
foreach (@all_nodes_mtm_serial_lines) {
    probe_utils->send_msg("$output", "d", "Processing $_.") if ($VERBOSE);
    my ($node_name, $value) = split ":", $_;
    if (exists($node_mtm_serial_hash{$node_name})) {
        # already have an entry for this node with mtm, concat the serial
        $value = $node_mtm_serial_hash{$node_name} . $value;
    }
    $node_mtm_serial_hash{$node_name} = $value;
}

#print Dumper(\%node_mtm_serial_hash) if ($VERBOSE);

# Build a hash of key="mtm+serial" value = "nodename" for all non-empty mtm+serial
my $any_dups = 0;
while (($node_name, $mtm_serial) = each %node_mtm_serial_hash) {
    # Check if hash already has the same key indicating another node definition has the same mtm+serial
    if (exists($mtm_serial_node_hash{$mtm_serial})) {
        if ($mtm_serial eq " mtm= serial=") {
            # Exclude entries that do not have mtm+serial set
            probe_utils->send_msg("$output", "d", "No mtm and no serial for node $node_name") if ($VERBOSE);
            next;
        }
        probe_utils->send_msg("$output", "f", "Duplicate node definition for $mtm_serial : $node_name and $mtm_serial_node_hash{$mtm_serial}.");

        # Remove entries from waiting_to_be_discovered hash if duplicate entry is detected
        if ($node_name =~ /$discovered_node_pattern/) {
            #probe_utils->send_msg("$output", "d", "Pattern match discovered node: $node_name") if ($VERBOSE);
            if (exists($waiting_to_be_discovered{$node_name})) {
                delete $waiting_to_be_discovered{$node_name};
                if ($DELETE_DUPLICATE) {
                    # Removing duplicat node entry
                    probe_utils->send_msg("$output", "d", "Removing node definition: $node_name") if ($VERBOSE);
                    my $remove_result = `rmdef $node_name`;
                }
            }
        }
        else {
            if ($mtm_serial_node_hash{$mtm_serial} =~ /$discovered_node_pattern/) {
                #probe_utils->send_msg("$output", "d", "Pattern match discovered node: $mtm_serial_node_hash{$mtm_serial}") if ($VERBOSE);
                $node_name = $mtm_serial_node_hash{$mtm_serial};
                if (exists($waiting_to_be_discovered{$node_name})) {
                    delete $waiting_to_be_discovered{$node_name};
                    if ($DELETE_DUPLICATE) {
                        # Removing duplicat node entry
                        probe_utils->send_msg("$output", "d", "Removing node definition: $node_name") if ($VERBOSE);
                        my $remove_result = `rmdef $node_name`;
                    }
                }
            }
        }
        $any_dups = 1;
    }
    else {
        $mtm_serial_node_hash{$mtm_serial} = $node_name;
        if ($node_name =~ /$discovered_node_pattern/) {
            # probe_utils->send_msg("$output", "d", "Pattern match discovered node: $node_name") if ($VERBOSE);
            # Add node to waiting_to_be_discovered hash, if later duplicate is found, this entry will be deleted
            $waiting_to_be_discovered{$node_name} = 1;
        }
    }
}

#print Dumper(\%mtm_serial_node_hash) if ($VERBOSE);
#print Dumper(\%waiting_to_be_discovered) if ($VERBOSE);

unless ($any_dups) {
    probe_utils->send_msg("$output", "o", "No nodes with duplicate mtm and serial numbers were found.");
}


# Display all discovered nodes (starting with "node-" that do not have a corresponding predefined node
foreach (keys %waiting_to_be_discovered) {
    probe_utils->send_msg("$output", "o", "$_: Waiting to be discovered");
}


exit 0;
